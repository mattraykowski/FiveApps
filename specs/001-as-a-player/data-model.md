# Data Model: Crew Member Leader Assignment

**Feature**: 001-as-a-player
**Date**: 2025-10-16
**Purpose**: Define data structures and relationships for leader designation

## Entity Changes

### CrewMember (Modified)

**Location**: `lib/five_apps/campaigns/crew_member.ex`
**Change Type**: Add attribute and custom change logic

#### New Attribute

| Field | Type | Constraints | Default | Description |
|-------|------|-------------|---------|-------------|
| `is_leader` | `boolean` | `allow_nil?: false`, `public?: true` | `false` | Indicates if this crew member is the designated leader of their campaign |

#### Attribute Definition

```elixir
attribute :is_leader, :boolean do
  default false
  allow_nil? false
  public? true
end
```

**Rationale**:
- Simple boolean flag matches the spec requirement (yes/no leadership status)
- Default `false` ensures all existing and new crew members start as non-leaders
- `allow_nil?: false` prevents ambiguous null states
- `public?: true` allows reading/writing through standard Ash APIs

#### Modified Actions

**Update Action** (add `is_leader` to accepted attributes and constraint logic):

```elixir
update :update do
  accept [
    :name,
    :species,
    :background,
    :motivation,
    :class,
    :gear,
    :notes,
    :reactions,
    :speed,
    :combat,
    :toughness,
    :savvy,
    :luck,
    :experience,
    :is_leader  # NEW
  ]

  argument :weapons, {:array, :map}, default: []

  require_atomic? false

  # NEW: Enforce one leader per campaign
  change FiveApps.Campaigns.Changes.EnsureSingleLeader

  change manage_relationship(:weapons, type: :direct_control)
end
```

**Destroy Action** (no changes needed):
- Existing cascade deletion automatically removes leader flag when crew member deleted
- Campaign left with no leader (valid state per spec)

### Campaign (No Changes)

**Location**: `lib/five_apps/campaigns/campaign.ex`
**Change Type**: None

**Rationale**:
- Campaign doesn't need direct reference to leader
- Leader identified by querying crew members where `is_leader == true`
- Keeps data model simple and normalized
- Existing `has_many :crew_members` relationship sufficient

## Custom Change Module

### EnsureSingleLeader

**Location**: `lib/five_apps/campaigns/changes/ensure_single_leader.ex` (new file)
**Purpose**: Enforce one-leader-per-campaign business rule

#### Logic

```elixir
defmodule FiveApps.Campaigns.Changes.EnsureSingleLeader do
  @moduledoc """
  Ensures only one crew member can be leader per campaign.

  When a crew member's is_leader is set to true, all other crew members
  in the same campaign have their is_leader flag set to false.
  """

  use Ash.Resource.Change

  @impl true
  def change(changeset, _opts, _context) do
    # Only act if is_leader is being set to true
    case Ash.Changeset.get_attribute(changeset, :is_leader) do
      true ->
        # Get the campaign_id from the record
        campaign_id = Ash.Changeset.get_attribute(changeset, :campaign_id)

        if campaign_id do
          # Add after_action hook to clear other leaders
          Ash.Changeset.after_action(changeset, fn _changeset, record ->
            clear_other_leaders(record, campaign_id)
            {:ok, record}
          end)
        else
          changeset
        end

      _other ->
        # is_leader is false or nil, no action needed
        changeset
    end
  end

  defp clear_other_leaders(current_crew_member, campaign_id) do
    # Query all crew members in campaign except current one
    FiveApps.Campaigns.CrewMember
    |> Ash.Query.filter(campaign_id == ^campaign_id and id != ^current_crew_member.id and is_leader == true)
    |> Ash.read!()
    |> Enum.each(fn crew_member ->
      # Clear leader flag
      crew_member
      |> Ash.Changeset.for_update(:update, %{is_leader: false})
      |> Ash.update!()
    end)
  end
end
```

**Key Design Decisions**:
1. **After Action Hook**: Ensures the current crew member is saved before clearing others (atomic)
2. **Conditional Logic**: Only acts when `is_leader` being set to `true` (optimization)
3. **Query Efficiency**: Filters to crew members that are currently leaders (minimal updates)
4. **Transaction Safety**: All updates happen within Ash transaction context

## Database Schema

### Migration: `add_leader_to_crew_members`

**Generated by**: `mix ash.codegen add_leader_to_crew_members`

#### Up

```sql
ALTER TABLE crew_members
ADD COLUMN is_leader BOOLEAN DEFAULT FALSE NOT NULL;
```

**Migration Safety**:
- ✅ Adds column with safe default (false)
- ✅ Non-nullable but has default (no existing data issues)
- ✅ Boolean type is simple and efficient
- ✅ No indexes initially (can add later if needed)

#### Down

```sql
ALTER TABLE crew_members
DROP COLUMN is_leader;
```

**Rollback Safety**:
- ✅ Simple column drop
- ✅ No foreign key dependencies
- ✅ No cascade issues

### Future Index (Optional)

If query performance becomes an issue:

```sql
-- Partial index for fast leader lookups
CREATE INDEX idx_crew_members_is_leader
ON crew_members (campaign_id)
WHERE is_leader = true;
```

**Rationale**:
- Partial index only includes leader records (small index size)
- Indexed by campaign_id for scoped queries
- Only needed if campaigns have many crew members (>100)
- Can be added later without code changes

## Data Validation Rules

### Attribute Level

| Rule | Validation | Error Message |
|------|------------|---------------|
| Type check | Ash boolean type | "must be a boolean" |
| Nil check | `allow_nil?: false` | "is required" |
| Default | `default false` | N/A (auto-set) |

### Business Logic Level

| Rule | Implementation | Error Handling |
|------|----------------|----------------|
| One leader per campaign | `EnsureSingleLeader` change | Silently clears others (user intent clear) |
| Leader in same campaign only | Scoped by `campaign_id` in query | Prevented by data model (belongs_to) |

**Error Scenarios**:
1. **Concurrent updates** - Ash transaction ensures last write wins, change module clears others atomically
2. **Invalid campaign** - Existing foreign key constraint prevents orphan crew members
3. **Deleted campaign** - Existing cascade rules handle cleanup

## State Transitions

### Leader Designation States

```
┌─────────────────┐
│  No Leader      │ ◄─┐
│  (all false)    │   │
└────────┬────────┘   │
         │ designate  │ remove leader
         │ leader     │ or delete leader
         ▼            │
┌─────────────────┐   │
│  Has Leader     │ ──┘
│  (one true)     │
└────────┬────────┘
         │ designate
         │ new leader
         │
         ▼
┌─────────────────┐
│  Leader         │
│  Transition     │ ──► Back to "Has Leader"
│  (atomic swap)  │     (new leader set,
└─────────────────┘      old cleared)
```

### Transition Rules

1. **No Leader → Has Leader**
   - Trigger: User toggles `is_leader` to `true` on any crew member
   - Action: Set `is_leader: true` on selected crew member
   - Result: Campaign has exactly one leader

2. **Has Leader → No Leader**
   - Trigger A: User toggles `is_leader` to `false` on current leader
   - Trigger B: User deletes current leader crew member
   - Action: Set/keep all `is_leader: false`
   - Result: Campaign has no leader (valid state)

3. **Has Leader → Has Leader (Different)**
   - Trigger: User toggles `is_leader` to `true` on different crew member
   - Action: Set new leader to `true`, automatically clear old leader to `false`
   - Result: Campaign has exactly one leader (the new one)

**Atomicity Guarantee**: All transitions happen within a single Ash transaction, ensuring data integrity.

## Querying Patterns

### Find Current Leader

```elixir
# In domain module or LiveView
def get_campaign_leader(campaign_id) do
  FiveApps.Campaigns.CrewMember
  |> Ash.Query.filter(campaign_id == ^campaign_id and is_leader == true)
  |> Ash.read_one()
end
```

**Returns**: `{:ok, crew_member}` or `{:ok, nil}` if no leader

### List All Crew Members with Leader Indicator

```elixir
# Already handled by existing query in LiveView
campaign = Campaigns.get_campaign!(id, load: [crew_members: [:weapons]])

# In template, check crew_member.is_leader
```

**No additional queries needed** - leader status loaded with crew members.

### Update Leader Designation

```elixir
# Via domain code interface
def set_crew_member_as_leader(crew_member_id, actor: actor) do
  crew_member = get_crew_member!(crew_member_id)

  Campaigns.update_crew_member(crew_member, %{is_leader: true}, actor: actor)
end
```

**Automatic behavior**: Setting `is_leader: true` triggers `EnsureSingleLeader` change.

## Data Integrity

### Constraints

| Constraint | Level | Enforcement |
|------------|-------|-------------|
| One leader per campaign | Application | `EnsureSingleLeader` custom change |
| Leader belongs to campaign | Database | Foreign key `campaign_id` |
| Boolean type | Database | Column type constraint |
| Not null | Database | `NOT NULL` constraint |

### Race Condition Handling

**Scenario**: Two users toggle different crew members as leader simultaneously

**Protection**:
1. Both requests enter separate Ash transactions
2. First transaction commits, sets leader A
3. Second transaction commits, sets leader B, triggers `EnsureSingleLeader`
4. Custom change queries current leaders (finds A), clears A, keeps B
5. Result: Only leader B remains (last write wins, consistency maintained)

**Postgres Isolation**: Ash uses Postgres transaction isolation to prevent partial states.

## Testing Data Fixtures

### Test Scenarios

```elixir
# test/support/fixtures/campaigns_fixtures.ex

def campaign_with_no_leader_fixture do
  campaign = campaign_fixture()
  crew_member_a = crew_member_fixture(campaign_id: campaign.id, name: "Alice")
  crew_member_b = crew_member_fixture(campaign_id: campaign.id, name: "Bob")

  %{campaign: campaign, crew_members: [crew_member_a, crew_member_b]}
end

def campaign_with_leader_fixture do
  %{campaign: campaign, crew_members: [a, b]} = campaign_with_no_leader_fixture()

  {:ok, a} = Campaigns.update_crew_member(a, %{is_leader: true})

  %{campaign: campaign, leader: a, other: b}
end
```

## Summary

| Aspect | Decision | Files Affected |
|--------|----------|----------------|
| **Data Model** | Add `is_leader` boolean to CrewMember | `crew_member.ex` |
| **Constraint** | Custom Ash change module | New file: `ensure_single_leader.ex` |
| **Migration** | Add column with safe default | Generated migration file |
| **Queries** | Use existing patterns, filter by `is_leader` | No new query patterns needed |
| **Validation** | Ash type system + business logic change | Handled by Ash Framework |
| **Testing** | Standard fixtures with leader variations | `campaigns_fixtures.ex` |

**Complexity**: Low - Single attribute addition with straightforward business logic.